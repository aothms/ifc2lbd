""" String TTL serializer.
So far, SPF will be behind in the contrary to the stream writer."""

from collections import defaultdict
from typing import Any, Dict, List, Tuple, Optional, Union, Callable
from pathlib import Path
import ifcopenshell
import ifcopenshell.ifcopenshell_wrapper as wrapper

from ifc2lbd.geometry import geometry_processor

def format_turtle_value(val, p, o):
    """
    Format value for Turtle syntax.
    """
    val_type = type(val)
    
    if val_type is str:
        return f'"{val}"'
    elif val_type is int:
        return f'"{val}"^^xsd:integer'
    elif val_type is float:
        return f'"{val}"^^xsd:double'
    elif val_type is bool:
        return f'"{str(val).lower()}"^^xsd:boolean'
    elif isinstance(val, ifcopenshell.entity_instance):
        return f"inst:{val.is_a()}_{val.id()}"
    else:
        return f'"{str(val)}"'

def string_writer_mini_ifcOWL(model, output_path: str, namespaces: Dict[str, str], geometry: Optional[geometry_processor] = None):
    """
    Write IFC model to Turtle TTL format.
    
    Args:
        model: IfcOpenShell model to serialize
        output_path: Path to output TTL file
        namespaces: Dictionary of prefix -> URI mappings (e.g., {"IFC": "...", "INST": "...", "XSD": "..."})
    """
    BASE = namespaces.get("BASE", "http://example.org/base#")
    INST = namespaces["inst"]
    XSD = namespaces["xsd"]

    if geometry:
        namespaces["geo"] = "http://www.opengis.net/ont/geosparql#"

    schema = wrapper.schema_by_name(model.schema_identifier)
    
    triple_count = 0
    entities_processed = 0

    with open(output_path, 'w', encoding='utf-8') as f:
        # Write prologue comments:
        f.write(f"# Turtle TTL output generated by LBD writer.\n")
        f.write(f"# baseURI: {BASE}\n")
        f.write(f"# imports: {namespaces['mifc']}\n")
        f.write("\n")
        f.write(f"BASE <{BASE}> .\n")
        for prefix, uri in namespaces.items():
            if prefix != "BASE":
                f.write(f"PREFIX {prefix}: <{uri}>\n")
        f.write("\n")

        f.write(f"inst:\ta\towl:Ontology ;\n")
        f.write(f"\towl:imports\tmifc: .\n\n")

        for idx, inst in enumerate(model):
            entities_processed += 1
            #print(instance_schema)
            # Subject IRI
            subj = f"inst:{inst.is_a()}_{inst.id()}"
            pred_obj = defaultdict(list)

            for attr_idx, value in enumerate(inst):
                if value is None:
                    continue
                # Predicate
                pred = f"ifc:{inst.attribute_name(attr_idx)}"

                # Values
                if isinstance(value, (list, tuple)):
                    for item in value:
                        if item is None:
                            continue
                        obj = format_turtle_value(item, INST, XSD)
                        pred_obj[pred].append(obj)
                else:
                    obj = format_turtle_value(value, INST, XSD)
                    pred_obj[pred].append(obj)

            if geometry:
                for s, p, o in geometry.lookup(inst, subj, namespaces=namespaces):
                    if s == subj:
                        pred_obj[p].append(o)
                    else:
                        # @todo should be further optimized, prefixes and all...
                        f.write(f"{s} {p} {o} .\n\n")
                        triple_count += 1

            f.write(f"{subj} a ifc:{inst.is_a()}")
            triple_count += 1

            if pred_obj:
                f.write(" ;\n")
                predicates = list(pred_obj.items())
                for i, (pred, objs) in enumerate(predicates):
                    objects_str = " , ".join(objs)
                    triple_count += len(objs)
                    if i < len(predicates) - 1:
                        f.write(f"\t{pred} {objects_str} ;\n")
                    else:
                        f.write(f"\t{pred} {objects_str} .\n\n")
            else:
                f.write(" .\n\n")
    
    return {
        'entities_processed': entities_processed,
        'triples_written': triple_count,
    }


# This one is still not functioning.

def string_writer_ifcOWL(model, output_path: str, namespaces: Dict[str, str], geometry: Optional[geometry_processor]= None):
    """
    Write IFC model to Turtle TTL format following full ifcOWL.
    
    In ifcOWL, predicates are named as: ifc:{AttributeName}_{DeclaredTypeName}
    For example: ifc:GlobalId_IfcGloballyUniqueId, ifc:Name_IfcLabel

    Args:
        model: IfcOpenShell model to serialize
        output_path: Path to output TTL file
        namespaces: Dictionary of prefix -> URI mappings (e.g., {"IFC": "...", "INST": "...", "XSD": "..."})
    """

    pass